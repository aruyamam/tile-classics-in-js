<!DOCTYPE html>
<html lang="ja">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <style>
      * {
         margin: 0;
         padding: 0;
      }
   </style>
</head>
<body>
   <canvas id="gameCanvas"></canvas>

   <script>
      var ballX = 75;
      var ballY = 75;
      var ballSpeedX = 5;
      var ballSpeedY = 7;

      const BRICK_W = 80;
      const BRICK_H = 20;
      const BRICK_GAP = 2;
      const BRICK_COLS = 10;
      const BRICK_ROWS = 14;
      var brickGrid = new Array(BRICK_COLS * BRICK_ROWS);

      const PADDLE_WIDTH = 100;
      const PADDLE_THICKNESS = 10;
      const PADDLE_DIST_FROM_EDGE = 60;
      var paddleX = 400;

      var canvas, canvasContext;

      var mouseX = 0;
      var mouseY = 0;

      function updateMousePos(evt) {
         var rect = canvas.getBoundingClientRect();
         var root = document.documentElement;

         mouseX = evt.clientX - rect.left - root.scrollLeft;
         mouseY = evt.clientY - rect.top - root.scrollTop;

         paddleX = mouseX - PADDLE_WIDTH / 2;
      }

      function brickReset() {
         for (let i = 0; i < BRICK_COLS * BRICK_ROWS; i++) {
            brickGrid[i] = true;
         }
      }

      window.onload = function () {
         canvas = document.getElementById('gameCanvas');
         canvasContext = canvas.getContext('2d');
         canvas.width = window.innerWidth;
         canvas.height = window.innerHeight - 7;

         var framesPerSecond = 30;
         setInterval(updateAll, 1000 / framesPerSecond);

         canvas.addEventListener('mousemove', updateMousePos);

         brickReset();
         // ballReset();
      }

      function updateAll() {
         moveAll();
         drawAll();
      }

      function ballReset() {
         ballX = canvas.width / 2;
         ballY = canvas.height / 2;
      }

      function moveAll() {
         ballX += ballSpeedX;
         ballY += ballSpeedY;
         
         if (ballX < 0) {
            ballSpeedX *= -1;
         }
         if (ballX > canvas.width) {
            ballSpeedX *= -1;
         }
         
         if (ballY < 0) {
            ballSpeedY *= -1;
         }
         if (ballY > canvas.height) {
            // ballReset();
            ballSpeedY *= -1;
         }

         var ballBrickCol = Math.floor(ballX / BRICK_W);
         var ballBrickRow = Math.floor(ballY / BRICK_H);
         var brickIndexUnderBall = rowColToArrayIndex(ballBrickCol, ballBrickRow);

         if (ballBrickCol >= 0 && ballBrickCol < BRICK_COLS
            && ballBrickRow >= 0 && ballBrickRow < BRICK_ROWS) {
               
               if (brickGrid[brickIndexUnderBall]) {
                  brickGrid[brickIndexUnderBall] = false;
                  ballSpeedY *= -1;
               }
         }

         var paddleTopEdgeY = canvas.height - PADDLE_DIST_FROM_EDGE;
         var paddleBottomEdgeY = paddleTopEdgeY + PADDLE_DIST_FROM_EDGE;
         var paddleLeftEdgeY = paddleX;
         var paddleRightEdgeY = paddleLeftEdgeY + PADDLE_WIDTH;

         if (
               ballY > paddleTopEdgeY &&
               ballY < paddleBottomEdgeY &&
               ballX > paddleLeftEdgeY &&
               ballX < paddleRightEdgeY
            ) {
               ballSpeedY *= -1;

               var centerOfPaddleX = paddleX + PADDLE_WIDTH / 2;
               var ballDistFromPaddleCenterX = ballX - centerOfPaddleX;
               ballSpeedX = ballDistFromPaddleCenterX * 0.35
         }
      }

      function rowColToArrayIndex(col, row) {
         return col + BRICK_COLS * row;
      }

      function drawBricks() {

         for (let eachRow = 0; eachRow < BRICK_ROWS; eachRow++) {
            for (let eachCol = 0; eachCol < BRICK_COLS; eachCol++) {
               var arrayIndex = rowColToArrayIndex(eachCol, eachRow);

               if (brickGrid[arrayIndex]) {
                  colorRect(BRICK_W * eachCol, BRICK_H * eachRow, BRICK_W - BRICK_GAP, BRICK_H - BRICK_GAP, 'blue');
               }
            }
         }
      }

      function drawAll() {
         // clear screen
         colorRect(0, 0, canvas.width, canvas.height, 'black');
         
         // draw ball
         colorCircle(ballX, ballY, 10, 'white');

         colorRect(paddleX, canvas.height - PADDLE_DIST_FROM_EDGE, PADDLE_WIDTH, PADDLE_THICKNESS)

         drawBricks();
      }

      function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor) {
         canvasContext.fillStyle = fillColor;
         canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
      }

      function colorCircle(centerX, centerY, radius, fillColor) {
         canvasContext.fillStyle = fillColor;
         canvasContext.beginPath();
         canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
         canvasContext.fill();
      }

      function colorText(showWords, textX, textY, fillColor) {
         canvasContext.fillStyle = fillColor;
         canvasContext.fillText(showWords, textX, textY);
      }
   </script>
</body>
</html>